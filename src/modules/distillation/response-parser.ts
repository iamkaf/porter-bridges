/**
 * @file Response Parser - Parses and validates AI responses
 *
 * This module handles parsing Gemini CLI responses, cleaning up output,
 * and validating against the distilled content schema.
 */

import { DistilledContentSchema } from '../../schemas/distilled-content-schema';
import { logger } from '../../utils/logger';
import { ValidationFixer } from './validation-fixer';

/**
 * Response parser class
 */
export class ResponseParser {
  private validationFixer: ValidationFixer;

  constructor(_geminiModel: string) {
    this.validationFixer = new ValidationFixer();
  }

  /**
   * Parse file content generated by Gemini (no validation, just trust valid JSON)
   */
  parseFileContent(fileContent: string) {
    try {
      // Parse JSON directly from file content - trust Gemini's output if it's valid JSON
      const parsed = JSON.parse(fileContent);
      logger.info('✅ Successfully parsed Gemini JSON output');
      return parsed;
    } catch (error: any) {
      logger.error(
        { error: error.message, fileContent: fileContent.substring(0, 500) },
        '❌ Failed to parse JSON from file content'
      );
      throw new Error(
        `Failed to parse JSON from file content: ${error.message}`
      );
    }
  }

  /**
   * Parse and validate Gemini response (legacy method for stdout parsing)
   */
  parseGeminiResponse(output: string) {
    try {
      // Clean up the output - remove MCP server messages and extract just the response
      const lines = output.split('\n');
      let cleanOutput = '';

      // Filter out MCP server messages and keep only the actual response
      for (const line of lines) {
        if (
          !(
            line.includes('MCP STDERR') ||
            line.includes('Context7 Documentation') ||
            line.includes('Linkie MCP server') ||
            line.includes('Connected to Linkie backend') ||
            line.includes('Available tools:') ||
            line.includes('Loaded cached credentials')
          ) &&
          line.trim() !== ''
        ) {
          cleanOutput += `${line}\n`;
        }
      }

      cleanOutput = cleanOutput.trim();

      // Try to find JSON in the cleaned output
      const jsonStart = cleanOutput.indexOf('{');
      const jsonEnd = cleanOutput.lastIndexOf('}');

      if (jsonStart === -1 || jsonEnd === -1) {
        throw new Error('No valid JSON found in Gemini response');
      }

      const jsonStr = cleanOutput.slice(jsonStart, jsonEnd + 1);
      const parsed = JSON.parse(jsonStr);

      // Validate against schema with safeParse to handle validation errors gracefully
      const validation = DistilledContentSchema.safeParse(parsed);

      if (!validation.success) {
        logger.warn(
          {
            errors: validation.error.issues,
            parsed: JSON.stringify(parsed, null, 2),
          },
          '⚠️  Schema validation failed, attempting to fix common issues'
        );

        // Try to fix common validation issues
        const fixed = this.validationFixer.fixCommonValidationIssues(parsed);
        const fixedValidation = DistilledContentSchema.safeParse(fixed);

        if (fixedValidation.success) {
          logger.info('✅ Fixed validation issues successfully');
          return fixedValidation.data;
        }
        logger.error(
          {
            errors: fixedValidation.error.issues,
            errorMessage: fixedValidation.error.message,
            output: JSON.stringify(fixed, null, 2),
          },
          '❌ Failed to fix validation issues'
        );
        throw new Error(
          `Schema validation failed: ${fixedValidation.error.message || JSON.stringify(fixedValidation.error.issues, null, 2)}`
        );
      }

      return validation.data;
    } catch (error: any) {
      logger.error(
        { error: error.message, output },
        '❌ Failed to parse Gemini response'
      );
      throw new Error(`Failed to parse Gemini response: ${error.message}`);
    }
  }
}

export default ResponseParser;
