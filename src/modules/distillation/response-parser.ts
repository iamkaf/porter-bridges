/**
 * @file Response Parser - Parses and validates AI responses
 *
 * This module handles parsing Gemini CLI responses, cleaning up output,
 * and validating against the distilled content schema.
 */

import { DistilledContentSchema } from '../../schemas/distilled-content-schema';
import { logger } from '../../utils/logger';
import { ValidationFixer } from './validation-fixer';
import { healJSON, logHealingStatsSummary } from '../../utils/json-healer';

/**
 * Response parser class
 */
export class ResponseParser {
  private validationFixer: ValidationFixer;
  private parseCount: number = 0;

  constructor(_geminiModel: string) {
    this.validationFixer = new ValidationFixer();
  }

  /**
   * Parse file content generated by Gemini (with JSON healing if needed)
   */
  parseFileContent(fileContent: string) {
    this.parseCount++;
    
    // Log healing statistics summary every 10 parse attempts
    if (this.parseCount % 10 === 0) {
      logHealingStatsSummary();
    }
    
    try {
      // First try to parse JSON directly
      const parsed = JSON.parse(fileContent);
      logger.info('✅ Successfully parsed Gemini JSON output');
      return parsed;
    } catch (initialError: any) {
      logger.warn(
        { error: initialError.message },
        '⚠️  Initial JSON parsing failed, attempting to heal JSON...'
      );
      
      // Try to heal the JSON
      const healResult = healJSON(fileContent);
      
      if (healResult.valid && healResult.repaired) {
        try {
          const parsed = JSON.parse(healResult.repaired);
          logger.info(
            `✅ JSON healed successfully using ${healResult.strategy} strategy`
          );
          return parsed;
        } catch (postHealError: any) {
          // This shouldn't happen if healResult.valid is true, but just in case
          logger.error(
            { error: postHealError.message },
            '❌ Failed to parse healed JSON (this should not happen)'
          );
        }
      }
      
      // JSON healing failed or didn't produce valid JSON
      logger.error(
        { 
          initialError: initialError.message,
          healError: healResult.error,
          fileContent: fileContent.substring(0, 500) 
        },
        '❌ Failed to parse JSON from file content even after healing attempt'
      );
      
      throw new Error(
        `Failed to parse JSON from file content: ${initialError.message}. Healing attempt also failed: ${healResult.error || 'Unknown error'}`
      );
    }
  }

  /**
   * Parse and validate Gemini response (legacy method for stdout parsing)
   */
  parseGeminiResponse(output: string) {
    try {
      // Clean up the output - remove MCP server messages and extract just the response
      const lines = output.split('\n');
      let cleanOutput = '';

      // Filter out MCP server messages and keep only the actual response
      for (const line of lines) {
        if (
          !(
            line.includes('MCP STDERR') ||
            line.includes('Context7 Documentation') ||
            line.includes('Linkie MCP server') ||
            line.includes('Connected to Linkie backend') ||
            line.includes('Available tools:') ||
            line.includes('Loaded cached credentials')
          ) &&
          line.trim() !== ''
        ) {
          cleanOutput += `${line}\n`;
        }
      }

      cleanOutput = cleanOutput.trim();

      // Try to find JSON in the cleaned output
      const jsonStart = cleanOutput.indexOf('{');
      const jsonEnd = cleanOutput.lastIndexOf('}');

      if (jsonStart === -1 || jsonEnd === -1) {
        throw new Error('No valid JSON found in Gemini response');
      }

      const jsonStr = cleanOutput.slice(jsonStart, jsonEnd + 1);
      const parsed = JSON.parse(jsonStr);

      // Validate against schema with safeParse to handle validation errors gracefully
      const validation = DistilledContentSchema.safeParse(parsed);

      if (!validation.success) {
        logger.warn(
          {
            errors: validation.error.issues,
            parsed: JSON.stringify(parsed, null, 2),
          },
          '⚠️  Schema validation failed, attempting to fix common issues'
        );

        // Try to fix common validation issues
        const fixed = this.validationFixer.fixCommonValidationIssues(parsed);
        const fixedValidation = DistilledContentSchema.safeParse(fixed);

        if (fixedValidation.success) {
          logger.info('✅ Fixed validation issues successfully');
          return fixedValidation.data;
        }
        logger.error(
          {
            errors: fixedValidation.error.issues,
            errorMessage: fixedValidation.error.message,
            output: JSON.stringify(fixed, null, 2),
          },
          '❌ Failed to fix validation issues'
        );
        throw new Error(
          `Schema validation failed: ${fixedValidation.error.message || JSON.stringify(fixedValidation.error.issues, null, 2)}`
        );
      }

      return validation.data;
    } catch (error: any) {
      logger.error(
        { error: error.message, output },
        '❌ Failed to parse Gemini response'
      );
      throw new Error(`Failed to parse Gemini response: ${error.message}`);
    }
  }
}

export default ResponseParser;
